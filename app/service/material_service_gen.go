// Code generated by platform, DO NOT EDIT.

package service

import (
	"context"
	"fmt"
	"database/sql"

	model "gitlab/nefco/platform/app/model"

	mssql "gitlab/nefco/platform/codegen/generate/service/mssql"
)

type MaterialMutationService interface {
	CreateMaterial(ctx context.Context, data model.MaterialCreateInput) (model.Material, error)
	UpdateMaterial(ctx context.Context, data model.MaterialUpdateInput, where model.MaterialWhereUniqueInput) (*model.Material, error)
	DeleteMaterial(ctx context.Context, where model.MaterialWhereUniqueInput) (*model.Material, error)
	UpsertMaterial(ctx context.Context, where model.MaterialWhereUniqueInput, create model.MaterialCreateInput, update model.MaterialUpdateInput) (*model.Material, error)
}

type materialMutationService struct{}

func NewMaterialMutationService() *materialMutationService {
	return &materialMutationService{}
}

func (s *materialMutationService) CreateMaterial(ctx context.Context, data model.MaterialCreateInput) (model.Material, error) {
	resSelect := model.Material{}

	tx, err := mssql.Begin(ctx)
	if err != nil {
		return resSelect, err
	}

	queryInsert := `
		INSERT INTO [co_material] (
			[name]
		) VALUES (
			:name
		)
	`

	resInsert, err := tx.NamedExec(queryInsert, &data)
	if err != nil {
		return resSelect, err
	}

	id, err := resInsert.LastInsertId()
	if err != nil {
		return resSelect, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name]
		FROM [co_material]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": id,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return resSelect, err
	}

	if err := stmt.Get(&resSelect, argSelect); err != nil {
		return resSelect, err
	}

	return resSelect, nil
}

func (s *materialMutationService) UpdateMaterial(ctx context.Context, data model.MaterialUpdateInput, where model.MaterialWhereUniqueInput) (*model.Material, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	queryUpdate := `
		UPDATE [co_material] SET
			[name] = :name
		WHERE id = :id
	`

	argUpdate := map[string]interface{}{
		"name": data.Name,
		"id": where.ID,
	}

	if _, err := tx.NamedExec(queryUpdate, argUpdate); err != nil {
		return nil, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name]
		FROM [co_material]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.Material{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *materialMutationService) DeleteMaterial(ctx context.Context, where model.MaterialWhereUniqueInput) (*model.Material, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name]
		FROM [co_material]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.Material{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	queryDelete := `
		DELETE FROM [co_material]
		WHERE id = :id
	`

	argDelete := map[string]interface{}{
		"id": where.ID,
	}

	if _, err = tx.NamedExec(queryDelete, argDelete); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *materialMutationService) UpsertMaterial(ctx context.Context, where model.MaterialWhereUniqueInput, create model.MaterialCreateInput, update model.MaterialUpdateInput) (*model.Material, error) {
	res := &model.Material{}

	tx, err := mssql.Begin(ctx)
	if err != nil {
		return res, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name]
		FROM [co_material]
		WHERE id = :id
	`

	arg := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	row := &model.Material{}

	var id interface{}
	action := "update"

	if err := stmt.Get(row, arg); err != nil {
		if err != sql.ErrNoRows {
		  return nil, err
		} else {
			action = "insert"
		}
	}

	if action == "insert" {
		queryInsert := `
			INSERT INTO [co_material] (
				[name]
			) VALUES (
				:name
			)
		`

		resInsert, err := tx.NamedExec(queryInsert, &create)
		if err != nil {
			return res, err
		}

		id, err = resInsert.LastInsertId()
		if err != nil {
			return nil, err
		}

	} else {
		queryUpdate := `
			UPDATE [co_material] SET
				[name] = :name
			WHERE id = :id
		`

		argUpdate := map[string]interface{}{
			"name": update.Name,
			"id": where.ID,
		}

		if _, err := tx.NamedExec(queryUpdate, argUpdate); err != nil {
			return nil, err
		}

		id = where.ID
	}

	querySelect = `
		SELECT 
			[id], 
			[name]
		FROM [co_material]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": id,
	}

	stmt, err = tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	if err := stmt.Get(res, argSelect); err != nil {
		return nil, err
	}

	return res, nil
}

type MaterialQueryService interface {
	Material(ctx context.Context, where model.MaterialWhereUniqueInput) (*model.Material, error)
	Materials(ctx context.Context, where *model.MaterialWhereInput, skip *int, first *int, last *int) ([]*model.Material, error)
}

type materialQueryService struct{}

func NewMaterialQueryService() *materialQueryService {
	return &materialQueryService{}
}

func (s *materialQueryService) Material(ctx context.Context, where model.MaterialWhereUniqueInput) (*model.Material, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name]
		FROM [co_material]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.Material{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *materialQueryService) Materials(ctx context.Context, where *model.MaterialWhereInput, skip *int, first *int, last *int) ([]*model.Material, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	var queryFrom string
	if skip != nil || first != nil || last != nil {
		queryFrom = `
			(
				SELECT 
			[id], 
			[name],
					ROW_NUMBER() OVER (ORDER BY id) AS num
				FROM [co_material]
			) AS result
		`
	} else {
		queryFrom = "[co_material]"
	}

	querySelect := fmt.Sprintf(`
		SELECT 
			[id], 
			[name]
		FROM %s
	`, queryFrom)

	argSelect := map[string]interface{}{}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := []*model.Material{}

	if err := stmt.Select(&resSelect, argSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}
