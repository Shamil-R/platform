// Code generated by platform, DO NOT EDIT.

package service

import (
	"context"
	"fmt"
	"database/sql"

	model "gitlab/nefco/platform/app/model"

	mssql "gitlab/nefco/platform/codegen/generate/service/mssql"
)

type PersonMutationService interface {
	CreatePerson(ctx context.Context, data model.PersonCreateInput) (model.Person, error)
	UpdatePerson(ctx context.Context, data model.PersonUpdateInput, where model.PersonWhereUniqueInput) (*model.Person, error)
	DeletePerson(ctx context.Context, where model.PersonWhereUniqueInput) (*model.Person, error)
	UpsertPerson(ctx context.Context, where model.PersonWhereUniqueInput, create model.PersonCreateInput, update model.PersonUpdateInput) (*model.Person, error)
}

type personMutationService struct{}

func NewPersonMutationService() *personMutationService {
	return &personMutationService{}
}

func (s *personMutationService) CreatePerson(ctx context.Context, data model.PersonCreateInput) (model.Person, error) {
	resSelect := model.Person{}

	tx, err := mssql.Begin(ctx)
	if err != nil {
		return resSelect, err
	}

	queryInsert := `
		INSERT INTO [co_person] (
			[name], 
			[surname], 
			[home_phone]
		) VALUES (
			:name, 
			:surname, 
			:phone
		)
	`

	resInsert, err := tx.NamedExec(queryInsert, &data)
	if err != nil {
		return resSelect, err
	}

	id, err := resInsert.LastInsertId()
	if err != nil {
		return resSelect, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM [co_person]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": id,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return resSelect, err
	}

	if err := stmt.Get(&resSelect, argSelect); err != nil {
		return resSelect, err
	}

	return resSelect, nil
}

func (s *personMutationService) UpdatePerson(ctx context.Context, data model.PersonUpdateInput, where model.PersonWhereUniqueInput) (*model.Person, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	queryUpdate := `
		UPDATE [co_person] SET
			[name] = :name, 
			[surname] = :surname, 
			[home_phone] = :phone
		WHERE id = :id
	`

	argUpdate := map[string]interface{}{
		"name": data.Name,
		"surname": data.Surname,
		"phone": data.Phone,
		"id": where.ID,
	}

	if _, err := tx.NamedExec(queryUpdate, argUpdate); err != nil {
		return nil, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM [co_person]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.Person{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *personMutationService) DeletePerson(ctx context.Context, where model.PersonWhereUniqueInput) (*model.Person, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM [co_person]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.Person{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	queryDelete := `
		DELETE FROM [co_person]
		WHERE id = :id
	`

	argDelete := map[string]interface{}{
		"id": where.ID,
	}

	if _, err = tx.NamedExec(queryDelete, argDelete); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *personMutationService) UpsertPerson(ctx context.Context, where model.PersonWhereUniqueInput, create model.PersonCreateInput, update model.PersonUpdateInput) (*model.Person, error) {
	res := &model.Person{}

	tx, err := mssql.Begin(ctx)
	if err != nil {
		return res, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM [co_person]
		WHERE id = :id
	`

	arg := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	row := &model.Person{}

	var id interface{}
	action := "update"

	if err := stmt.Get(row, arg); err != nil {
		if err != sql.ErrNoRows {
		  return nil, err
		} else {
			action = "insert"
		}
	}

	if action == "insert" {
		queryInsert := `
			INSERT INTO [co_person] (
				[name], 
				[surname], 
				[home_phone]
			) VALUES (
				:name, 
				:surname, 
				:phone
			)
		`

		resInsert, err := tx.NamedExec(queryInsert, &create)
		if err != nil {
			return res, err
		}

		id, err = resInsert.LastInsertId()
		if err != nil {
			return nil, err
		}

	} else {
		queryUpdate := `
			UPDATE [co_person] SET
				[name] = :name, 
				[surname] = :surname, 
				[home_phone] = :phone
			WHERE id = :id
		`

		argUpdate := map[string]interface{}{
			"name": update.Name,
			"surname": update.Surname,
			"phone": update.Phone,
			"id": where.ID,
		}

		if _, err := tx.NamedExec(queryUpdate, argUpdate); err != nil {
			return nil, err
		}

		id = where.ID
	}

	querySelect = `
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM [co_person]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": id,
	}

	stmt, err = tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	if err := stmt.Get(res, argSelect); err != nil {
		return nil, err
	}

	return res, nil
}

type PersonQueryService interface {
	Person(ctx context.Context, where model.PersonWhereUniqueInput) (*model.Person, error)
	People(ctx context.Context, where *model.PersonWhereInput, skip *int, first *int, last *int) ([]*model.Person, error)
}

type personQueryService struct{}

func NewPersonQueryService() *personQueryService {
	return &personQueryService{}
}

func (s *personQueryService) Person(ctx context.Context, where model.PersonWhereUniqueInput) (*model.Person, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	querySelect := `
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM [co_person]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.Person{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *personQueryService) People(ctx context.Context, where *model.PersonWhereInput, skip *int, first *int, last *int) ([]*model.Person, error) {
	tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	var queryFrom string
	if skip != nil || first != nil || last != nil {
		queryFrom = `
			(
				SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone,
					ROW_NUMBER() OVER (ORDER BY id) AS num
				FROM [co_person]
			) AS result
		`
	} else {
		queryFrom = "[co_person]"
	}

	querySelect := fmt.Sprintf(`
		SELECT 
			[id], 
			[name], 
			[surname], 
			[home_phone] AS phone
		FROM %s
	`, queryFrom)

	argSelect := map[string]interface{}{}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := []*model.Person{}

	if err := stmt.Select(&resSelect, argSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}
