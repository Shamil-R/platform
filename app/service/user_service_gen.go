// Code generated by platform, DO NOT EDIT.

package service

import (
	"context"
	"database/sql"
	model "gitlab/nefco/platform/app/model"
	mssql "gitlab/nefco/platform/codegen/generate/service/mssql"
)

type UserMutationService interface {
	CreateUser(ctx context.Context, data model.UserCreateInput) (model.User, error)
	UpdateUser(ctx context.Context, data model.UserUpdateInput, where model.UserWhereUniqueInput) (*model.User, error)
	DeleteUser(ctx context.Context, where model.UserWhereUniqueInput) (*model.User, error)
	UpsertUser(ctx context.Context, where model.UserWhereUniqueInput, create model.UserCreateInput, update model.UserUpdateInput) (*model.User, error)
}

type MSSQLUserMutationService struct{}

func NewUserMutationService() *MSSQLUserMutationService {
	return &MSSQLUserMutationService{}
}

func (s *MSSQLUserMutationService) CreateUser(ctx context.Context, data model.UserCreateInput) (model.User, error) {
	resSelect := model.User{}

	/* tx, err := mssql.Begin(ctx)
	if err != nil {
		return resSelect, err
	}

	queryInsert := `
		INSERT INTO [user] (
			[name]
		) VALUES (
			:name
		)
	`

	resInsert, err := tx.NamedExec(queryInsert, &data)
	if err != nil {
		return resSelect, err
	}

	id, err := resInsert.LastInsertId()
	if err != nil {
		return resSelect, err
	}

	querySelect := `
		SELECT
			[id],
			[name]
		FROM [user]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": id,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return resSelect, err
	}

	if err := stmt.Get(&resSelect, argSelect); err != nil {
		return resSelect, err
	} */

	if err := mssql.Create(ctx, &resSelect); err != nil {
		return resSelect, err
	}

	return resSelect, nil
}

func (s *MSSQLUserMutationService) UpdateUser(ctx context.Context, data model.UserUpdateInput, where model.UserWhereUniqueInput) (*model.User, error) {
	// tx, err := mssql.Begin(ctx)
	// if err != nil {
	// 	return nil, err
	// }

	// queryUpdate := `
	// 	UPDATE [user] SET
	// 		[name] = :name
	// 	WHERE id = :id
	// `

	// argUpdate := map[string]interface{}{
	// 	"name": data.Name,
	// 	"id":   where.ID,
	// }

	// if _, err := tx.NamedExec(queryUpdate, argUpdate); err != nil {
	// 	return nil, err
	// }

	// querySelect := `
	// 	SELECT
	// 		[id],
	// 		[name]
	// 	FROM [user]
	// 	WHERE id = :id
	// `

	// argSelect := map[string]interface{}{
	// 	"id": where.ID,
	// }

	// stmt, err := tx.PrepareNamed(querySelect)
	// if err != nil {
	// 	return nil, err
	// }

	resSelect := &model.User{}

	// if err := stmt.Get(resSelect, argSelect); err != nil {
	// 	return nil, err
	// }

	if err := mssql.Update(ctx, resSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *MSSQLUserMutationService) DeleteUser(ctx context.Context, where model.UserWhereUniqueInput) (*model.User, error) {
	/* tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	querySelect := `
		SELECT
			[id],
			[name]
		FROM [user]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	resSelect := &model.User{}

	if err := stmt.Get(resSelect, argSelect); err != nil {
		return nil, err
	}

	queryDelete := `
		DELETE FROM [user]
		WHERE id = :id
	`

	argDelete := map[string]interface{}{
		"id": where.ID,
	}

	if _, err = tx.NamedExec(queryDelete, argDelete); err != nil {
		return nil, err
	} */

	resSelect := &model.User{}

	if err := mssql.Delete(ctx, resSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *MSSQLUserMutationService) UpsertUser(ctx context.Context, where model.UserWhereUniqueInput, create model.UserCreateInput, update model.UserUpdateInput) (*model.User, error) {
	res := &model.User{}

	tx, err := mssql.Begin(ctx)
	if err != nil {
		return res, err
	}

	querySelect := `
		SELECT
			[id],
			[name]
		FROM [user]
		WHERE id = :id
	`

	arg := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	row := &model.User{}

	var id interface{}
	action := "update"

	if err := stmt.Get(row, arg); err != nil {
		if err != sql.ErrNoRows {
			return nil, err
		} else {
			action = "insert"
		}
	}

	if action == "insert" {
		queryInsert := `
			INSERT INTO [user] (
				[name]
			) VALUES (
				:name
			)
		`

		resInsert, err := tx.NamedExec(queryInsert, &create)
		if err != nil {
			return res, err
		}

		id, err = resInsert.LastInsertId()
		if err != nil {
			return nil, err
		}

	} else {
		queryUpdate := `
			UPDATE [user] SET
				[name] = :name
			WHERE id = :id
		`

		argUpdate := map[string]interface{}{
			"name": update.Name,
			"id":   where.ID,
		}

		if _, err := tx.NamedExec(queryUpdate, argUpdate); err != nil {
			return nil, err
		}

		id = where.ID
	}

	querySelect = `
		SELECT
			[id],
			[name]
		FROM [user]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": id,
	}

	stmt, err = tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	}

	if err := stmt.Get(res, argSelect); err != nil {
		return nil, err
	}

	return res, nil
}

type UserQueryService interface {
	User(ctx context.Context, where model.UserWhereUniqueInput) (*model.User, error)
	Users(ctx context.Context, where *model.UserWhereInput, skip *int, first *int, last *int) ([]*model.User, error)
}

type MSSQLUserQueryService struct{}

func NewUserQueryService() *MSSQLUserQueryService {
	return &MSSQLUserQueryService{}
}

func (s *MSSQLUserQueryService) User(ctx context.Context, where model.UserWhereUniqueInput) (*model.User, error) {
	/* tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	querySelect := `
		SELECT
			[id],
			[name]
		FROM [user]
		WHERE id = :id
	`

	argSelect := map[string]interface{}{
		"id": where.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	} */

	resSelect := &model.User{}

	// if err := stmt.Get(resSelect, argSelect); err != nil {
	// 	return nil, err
	// }

	if err := mssql.Item(ctx, resSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

func (s *MSSQLUserQueryService) Users(ctx context.Context, where *model.UserWhereInput, skip *int, first *int, last *int) ([]*model.User, error) {
	/* tx, err := mssql.Begin(ctx)
	if err != nil {
		return nil, err
	}

	var queryFrom string
	if skip != nil || first != nil || last != nil {
		queryFrom = `
			(
				SELECT
			[id],
			[name],
					ROW_NUMBER() OVER (ORDER BY id) AS num
				FROM [user]
			) AS result
		`
	} else {
		queryFrom = "[user]"
	}

	querySelect := fmt.Sprintf(`
		SELECT
			[id],
			[name]
		FROM %s
	`, queryFrom)

	argSelect := map[string]interface{}{}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return nil, err
	} */

	resSelect := []*model.User{}

	// if err := stmt.Select(&resSelect, argSelect); err != nil {
	// 	return nil, err
	// }

	if err := mssql.Collection(ctx, &resSelect); err != nil {
		return nil, err
	}

	return resSelect, nil
}

type UserRelationService interface {
	Materials(ctx context.Context, obj *model.User, where *model.MaterialWhereInput) ([]model.Material, error)
}

type userRelationService struct{}

func NewUserRelationService() *userRelationService {
	return &userRelationService{}
}

func (s *userRelationService) Materials(ctx context.Context, obj *model.User, where *model.MaterialWhereInput) ([]model.Material, error) {
	resSelect := []model.Material{}

	tx, err := mssql.Begin(ctx)
	if err != nil {
		return resSelect, err
	}

	querySelect := `
		SELECT *
		FROM [co_material]
		WHERE user_id = :id
	`
	argSelect := map[string]interface{}{
		"id": obj.ID,
	}

	stmt, err := tx.PrepareNamed(querySelect)
	if err != nil {
		return resSelect, err
	}

	if err := stmt.Select(&resSelect, argSelect); err != nil {
		return resSelect, err
	}

	return resSelect, nil
}
